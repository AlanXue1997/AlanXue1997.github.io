<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>DBSCAN</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@XueZhonghao" /><meta name="twitter:title" content="DBSCAN" /><meta name="twitter:description" content=""><meta name="description" content=""><meta name="google-site-verification" content="epFgX0s_0RM3CdjwFcsewfXzPov2g8s9ZBOLyaIUH-o"><link rel="shortcut icon" href="/assets/totora.png"> <!--<link rel="icon" href="/assets/totora.png">--><link rel="apple-touch-icon" href="/assets/touch-icon.png"><link rel="stylesheet" href="//code.cdn.mozilla.net/fonts/fira.css"><link rel="stylesheet" href="/assets/core.css"><link rel="stylesheet" href="/assets/prism.css"><link rel="canonical" href="/notes/DBSCAN"><link rel="alternate" type="application/atom+xml" title="AlanXue's blog" href="/feed.xml" /> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-79196511-1', 'auto'); ga('send', 'pageview'); </script></head><body><aside class="logo"> <a href="/"> <img src="/assets/Totora2.png"> </a> <span class="logo-prompt">Back to Home</span></aside><!--src="http://www.gravatar.com/avatar/742cf6353760888dd24b7f22843cca55.png?s=80" class="gravatar" --><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>DBSCAN</h1><time>March 10, 2017</time></div><div class="divider"></div><script src="/assets/prism.js"></script><h1 id="section">前言</h1><p>参加了老师的一个项目，要搞劣质数据对机器学习算法的影响，我负责实现<a href="https://zh.wikipedia.org/wiki/DBSCAN">DBSCAN算法</a>。</p><div class="divider"></div><h1 id="section-1">定义</h1><h2 id="section-2">参数</h2><p>ε(eps)：邻域半径</p><p>minPts：形成核心点最少的点数</p><h2 id="section-3">距离</h2><p>在二维（每个数据只有两个属性）的情况下，使用欧氏距离(sqrt(x^2+y^2))就可以有很好的效果，但对于更高维度的数据，欧氏距离是不适用的。</p><h2 id="section-4">点的可达性</h2><p>如果点p在距离ε内有至少minPts个点,则点p被称为<strong>核心点(core point)</strong>，p距离ε内的其他点被称为<strong>p的直接可达点(directly density-reachable point)</strong>。</p><p>对于点p和q，如果存在一个序列{p1,p2,…,pn}，其中p1=p，pn=1，满足∀i∈N,i&lt;n有pi+1是pi的直接可达点，则称q为<strong>p的可达点(density-reachable point)</strong>。</p><p>对于点p和q，如果存在点o，p和q都是o的可达点，则称p和q是<strong>密度连接(density-connected)</strong>的。</p><p>如果点p不是任何点的可达点，则称p为<strong>局外点</strong>。</p><h2 id="section-5">聚类</h2><p>一个聚类满足如下性质：</p><div class="highlighter-rouge"><pre class="highlight"><code>1.聚类中的任意两个点都是密度连接的。

2.聚类中的任意点的可达点仍属于这个聚类。
</code></pre></div><div class="divider"></div><h1 id="section-6">算法</h1><blockquote><p>①对于每一个点，判断其是否为核心点</p><p>②新建一个聚类cluster</p><p>③找到一个没有被访问的点，放入cluster。如果所有店都被访问，则程序结束。</p><p>④根据cluster中点的可达点进行搜索，将搜索到的未被访问的点放入cluster，并标记为已访问。</p><p>⑤重复②</p></blockquote><div class="divider"></div><h1 id="section-7">代码</h1><div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
</span>
<span class="cp">#define pointSet std::vector&lt;point&gt;
#define pointerSet std::vector&lt;int&gt;
</span>
<span class="cp">#define NOT_VISTED -1
#define WRITE_TO_FILE
#define ATTRIBUTIONS 4
</span>
<span class="cp">#define minPts 4
#define E 0.1
</span><span class="c1">//it is actually squared e
</span>
<span class="k">class</span> <span class="nc">point</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="kt">double</span> <span class="n">a</span><span class="p">[</span><span class="n">ATTRIBUTIONS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ddr</span><span class="p">;</span><span class="c1">//amount of directly density-reachable points
</span>	<span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flag_ans</span><span class="p">;</span>
	<span class="n">pointerSet</span> <span class="o">*</span><span class="n">ddrs</span><span class="p">;</span>
	<span class="n">point</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="n">attributions</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag_ans</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ATTRIBUTIONS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">ddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ddrs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">flag</span> <span class="o">=</span> <span class="n">NOT_VISTED</span><span class="p">;</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">flag_ans</span> <span class="o">=</span> <span class="n">flag_ans</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">double</span> <span class="n">distance</span><span class="p">(</span><span class="k">const</span> <span class="n">point</span> <span class="o">&amp;</span><span class="n">p0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ATTRIBUTIONS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">p0</span><span class="p">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">p0</span><span class="p">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">sum</span><span class="p">;</span><span class="c1">//there is no sqrt() because E have been squared
</span>	<span class="p">}</span>
	<span class="n">bool</span> <span class="k">operator</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">point</span> <span class="o">&amp;</span><span class="n">p0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ATTRIBUTIONS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p0</span><span class="p">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p0</span><span class="p">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">DBSCAN</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">DBSCAN</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">fin</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
		<span class="n">fin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">double</span> <span class="n">attributions</span><span class="p">[</span><span class="n">ATTRIBUTIONS</span><span class="p">];</span>
			<span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ATTRIBUTIONS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">fin</span> <span class="o">&gt;&gt;</span> <span class="n">attributions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="n">fin</span> <span class="o">&gt;&gt;</span> <span class="n">flag</span><span class="p">;</span>
			<span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">point</span><span class="p">(</span><span class="n">attributions</span><span class="p">,</span> <span class="n">flag</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">fin</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="c1">//To calcute ddr(amount directly density-reachable points) of every point and save ddrs(directly density-reachable points) for each CORE points
</span>	<span class="kt">void</span> <span class="n">calcDdr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pointerSet</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">pointerSet</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">distance</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ddr</span><span class="o">++</span><span class="p">;</span>
					<span class="n">p</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ddr</span> <span class="o">&gt;=</span> <span class="n">minPts</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ddrs</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">delete</span> <span class="n">p</span><span class="p">;</span><span class="c1">//if point i is not a core point, we need not to know its directly density-reachable points
</span>			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">DFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">point</span> <span class="o">&amp;</span><span class="n">p</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
		<span class="n">p</span><span class="p">.</span><span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">ddrs</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">ddrs</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">)].</span><span class="n">flag</span> <span class="o">==</span> <span class="n">NOT_VISTED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">points</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">ddrs</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">)].</span><span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">ddrs</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">)].</span><span class="n">ddr</span> <span class="o">&gt;=</span> <span class="n">minPts</span><span class="p">)</span> <span class="n">DFS</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">ddrs</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">flag</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">process</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">calcDdr</span><span class="p">();</span>
		<span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flag</span> <span class="o">==</span> <span class="n">NOT_VISTED</span> <span class="o">&amp;&amp;</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ddr</span> <span class="o">&gt;=</span> <span class="n">minPts</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DFS</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">flag</span><span class="o">++</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#ifdef WRITE_TO_FILE
</span>		<span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">fout</span><span class="p">(</span><span class="s">"output.txt"</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ATTRIBUTIONS</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">fout</span> <span class="o">&lt;&lt;</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">'\t'</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">fout</span> <span class="o">&lt;&lt;</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flag</span> <span class="o">&lt;&lt;</span> <span class="sc">'\t'</span> <span class="o">&lt;&lt;</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flag_ans</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fout</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="cp">#else
</span>		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ATTRIBUTIONS</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
	<span class="p">}</span>
			<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flag</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif
</span>	<span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
	<span class="kt">int</span> <span class="n">N</span><span class="p">;</span>
	<span class="n">pointSet</span> <span class="n">points</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">DBSCAN</span> <span class="n">dbscan</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">);</span>
	<span class="n">dbscan</span><span class="p">.</span><span class="n">process</span><span class="p">();</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="divider"></div><h1 id="section-8">效果</h1><p>二维的情况，看起来聚类的结果还是很好的，由于只使用了四个属性中的两个，所以没有将原始数据的三个集合给区分出来，但明显能看出来将相近的点分成了同样的颜色（灰色代表噪声）。</p><p><img src="/assets/dbscan.png" /></p><p>但在高维数据上，使用欧氏距离计算密度的DBSCAN的效果就不是很好了，甚至可以说非常不好，例如我用的iris数据，如果将四个属性全用上，则不管怎么调整参数，都无法大致将数据分成三类，虽然四维图像无法显示，但从输出来看，结果跟上图是差不多了，有两类无法分开。</p><div class="divider"></div></article><div class="back"> <a href="/">Back</a></div></main></body></html>